<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Massively Parallel Trotter-Suzuki Solver: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="vortex.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Massively Parallel Trotter-Suzuki Solver
   &#160;<span id="projectnumber">1.5.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="md_download.html"><span>Download&#160;and&#160;Installation</span></a></li>
      <li><a href="md_tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="md_examples.html"><span>Examples</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial is about using the command-line interface and the C++ API. If you are interested in the Python version, refer to <a href="https://trotter-suzuki-mpi.readthedocs.org">Read the Docs</a>.</p>
<h2>Command-line Interface </h2>
<p>The command-line interface is severely limited in functionality. For instance, only static external potential and single-component Hamiltonians are supported. Most functionality related to the solution of various flavours of the Gross-Pitaevskii equation is also inaccessible. It is primarily useful to study the evolution of states with the linear Schr√∂dinger equation. For anything more complicated, please use the C++ API or the Python interface.</p>
<p>Usage: <code>trottersuzuki [OPTIONS] -n filename</code></p>
<p>The file specified contains the complex matrix describing the initial state in the position picture.</p>
<p>Arguments: </p>
<pre class="fragment">-m NUMBER     Particle mass
-c NUMBER     Coupling constant of the self-interacting term (default: 0)
-d NUMBER     Matrix dimension (default: 640)
-l NUMBER     Physical dimension of the square lattice's edge (default: 640)
-t NUMBER     Single time step (default: 0.01)
-i NUMBER     Number of iterations (default: 1000)
-g            Imaginary time evolution to evolve towards the ground state
-k NUMBER     Kernel type (default: 0):
                0: CPU, cache-optimized
                2: GPU
                3: Hybrid CPU-GPU (experimental)                    
-s NUMBER     Snapshots are taken at every NUMBER of iterations.
                Zero means no snapshots. Default: 0.
-n FILENAME   The initial state.
-p FILENAME   Name of file that stores the potential operator
              (in coordinate representation)
</pre><p>Examples:</p>
<p>For using all cores of the CPU kernel with OpenMP parallelization starting on some initial state of size 640x640 in psi0.dat and taking snapshots at every ten iterations, type: </p>
<pre class="fragment">trottersuzuki -i 100 -d 640 -s 10 -n psi0.dat
</pre><p>For a hundred iterations with a GPU, enter: </p>
<pre class="fragment">trotter -k 2 -i 100 -d 640 -s 10 -n psi0.dat
</pre><p>To run it on a cluster, you must compile the code with MPI. In this case, OpenMP parallelization is disabled in the CPU kernel. Hence the total number of MPI processes must match your number of cores per node multiplied by the total number of nodes. Say, with an eight core CPU in four nodes, you would type </p>
<pre class="fragment">mpirun -np 32 trotter -i 100 -d 640 -s 10 -n psi0.dat
</pre><p>Naturally, if the system is distributed, MPI must be told of a host file.</p>
<p>The hybrid kernel is experimental. It splits the work between the GPU and the CPU. It uses one MPI thread per GPU, and uses OpenMP to use parallelism on the CPU. It can be faster than the GPU kernel alone, especially if the GPU is consumer-grade. The kernel is especially efficient if the matrix does not fit the GPU memory. For instance, given twelve physical cores in a single node with two Tesla C2050 GPUs, a 14,000x14,000 would not fit the GPU memory. The following command would calculate the part that does not fit the device memory on the CPU: </p>
<pre class="fragment">OMP_NUM_THREADS=6 mpirun -np 2 build/trotter -k 3 -i 100 -d 14000 -n psi0.dat
</pre><h2>Application Programming Interface </h2>
<p>The command-line interface is restricted in what it can do and the full capabalities of the library are unleashed through its C++ API. Here we give an introduction to the features.</p>
<p><b>Multicore computations</b></p>
<p>This example uses all cores on a single computer to calculate the total energy after evolving a sinusoid initial state. First we set the physical and simulation parameters of the model. We set the mass equal to one, we discretize the space in 500 lattice points in either direction, and we set the physical length to the same value. We would like to have a hundred iterations with 0.01 second between each:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> particle_mass = 1.;</div>
<div class="line"><span class="keywordtype">int</span> dimension = 500.;</div>
<div class="line"><span class="keywordtype">double</span> length = double(dimension);</div>
<div class="line"><span class="keywordtype">double</span> delta_t = 0.01;</div>
<div class="line"><span class="keywordtype">int</span> iterations  = 100;</div>
</div><!-- fragment --><p>The next step is the define the lattice, the state, and the <a class="el" href="classHamiltonian.html" title="This class defines the Hamiltonian of a single component system. ">Hamiltonian</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classLattice.html">Lattice</a> *grid = <span class="keyword">new</span> <a class="code" href="classLattice.html">Lattice</a>(dimension, length);</div>
<div class="line"><a class="code" href="classState.html">State</a> *state = <span class="keyword">new</span> <a class="code" href="classSinusoidState.html">SinusoidState</a>(grid, 1, 1);</div>
<div class="line"><a class="code" href="classHamiltonian.html">Hamiltonian</a> *hamiltonian = <span class="keyword">new</span> <a class="code" href="classHamiltonian.html">Hamiltonian</a>(grid, NULL, particle_mass);</div>
</div><!-- fragment --><p>With these objects representing the physics of the problem, we can initialize the solver:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t);</div>
</div><!-- fragment --><p>Then we can evolve the state for the hundred iterations:</p>
<div class="fragment"><div class="line">solver-&gt;<a class="code" href="classSolver.html#afef4d30f0fafcdd30e4bbd68ab4b8d18">evolve</a>(iterations);</div>
</div><!-- fragment --><p>If we would like to have imaginary time evolution to approximate the ground state of the system, a second boolean parameter can be passed to the <code>evolve</code> method. Flipping it to true will yield imaginary time evolution.</p>
<p>We can write the evolved state to a file:</p>
<div class="fragment"><div class="line">state-&gt;<a class="code" href="classState.html#a30ef4054140d4add7904c2e75b879b2d">write_to_file</a>(<span class="stringliteral">&quot;evolved_state&quot;</span>);</div>
</div><!-- fragment --><p>If we need a series of snapshots of the evolution, say, every hundred iterations, we can loop these two steps, adjusting the prefix of the file to be written to reflect the number of evolution steps.</p>
<p>Finally, we can calculate the expectation value of the energies:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Squared norm: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#ac19c0fcf546647fd08c264010b02ee7b">get_squared_norm</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; Kinetic energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#a9ab0c2e624be8dc9e15cd6ebf4c83566">get_kinetic_energy</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; Total energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#aeb5ea40d4c6cba2312f05e839fb1cf8e">get_total_energy</a>() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The following file, <code>simple_example.cpp</code>, summarizes the above:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;trottersuzuki.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <span class="keywordtype">double</span> particle_mass = 1.;</div>
<div class="line">    <span class="keywordtype">int</span> dimension = 500.;</div>
<div class="line">    <span class="keywordtype">double</span> length = double(dimension);</div>
<div class="line">    <span class="keywordtype">double</span> delta_t = 0.01;</div>
<div class="line">    <span class="keywordtype">int</span> iterations  = 100;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classLattice.html">Lattice</a> *grid = <span class="keyword">new</span> <a class="code" href="classLattice.html">Lattice</a>(dimension, length);</div>
<div class="line">    <a class="code" href="classState.html">State</a> *state = <span class="keyword">new</span> <a class="code" href="classSinusoidState.html">SinusoidState</a>(grid, 1, 1);</div>
<div class="line">    <a class="code" href="classHamiltonian.html">Hamiltonian</a> *hamiltonian = <span class="keyword">new</span> <a class="code" href="classHamiltonian.html">Hamiltonian</a>(grid, NULL, particle_mass);</div>
<div class="line">    <a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t);</div>
<div class="line"></div>
<div class="line">    solver-&gt;<a class="code" href="classSolver.html#afef4d30f0fafcdd30e4bbd68ab4b8d18">evolve</a>(iterations);</div>
<div class="line">    state-&gt;<a class="code" href="classState.html#a30ef4054140d4add7904c2e75b879b2d">write_to_file</a>(<span class="stringliteral">&quot;evolved_state&quot;</span>);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Squared norm: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#ac19c0fcf546647fd08c264010b02ee7b">get_squared_norm</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Kinetic energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#a9ab0c2e624be8dc9e15cd6ebf4c83566">get_kinetic_energy</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Total energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#aeb5ea40d4c6cba2312f05e839fb1cf8e">get_total_energy</a>() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keyword">delete</span> solver;</div>
<div class="line">    <span class="keyword">delete</span> hamiltonian;</div>
<div class="line">    <span class="keyword">delete</span> state;</div>
<div class="line">    <span class="keyword">delete</span> grid;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compile it with</p>
<div class="fragment"><div class="line">g++ -I/PATH/TO/TROTTERSUZUKI/HEADER -L/PATH/TO/TROTTERSUZUKI/LIBRARY simple_example.cpp -o simple_example -ltrottersuzuki</div>
</div><!-- fragment --><p><b>GPU version</b></p>
<p>If the library was compiled with CUDA support, it is enough to change a single line of code, requesting the GPU kernel when instantiating the solver class:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t, <span class="stringliteral">&quot;gpu&quot;</span>);</div>
</div><!-- fragment --><p>The compilation is the same as above.</p>
<p><b>Distributed version</b></p>
<p>There is very little modification required in the code to make it work with MPI. It is sufficient to initialize MPI and finalize it before returning from <code>main</code>. It is worth noting that the <code><a class="el" href="classLattice.html" title="This class defines the lattice structure over which the state and potential matrices are defined...">Lattice</a></code> class keeps track of the MPI-related topology, and it also knows the MPI rank of the current process. The code for <code>simple_example_mpi.cpp</code> is as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;trottersuzuki.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="preprocessor"></span>    MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line"><span class="preprocessor">#endif  </span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordtype">double</span> particle_mass = 1.;</div>
<div class="line">    <span class="keywordtype">int</span> dimension = 500.;</div>
<div class="line">    <span class="keywordtype">double</span> length = double(dimension);</div>
<div class="line">    <span class="keywordtype">double</span> delta_t = 0.01;</div>
<div class="line">    <span class="keywordtype">int</span> iterations  = 100;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classLattice.html">Lattice</a> *grid = <span class="keyword">new</span> <a class="code" href="classLattice.html">Lattice</a>(dimension, length);</div>
<div class="line">    <a class="code" href="classState.html">State</a> *state = <span class="keyword">new</span> <a class="code" href="classSinusoidState.html">SinusoidState</a>(grid, 1, 1);</div>
<div class="line">    <a class="code" href="classHamiltonian.html">Hamiltonian</a> *hamiltonian = <span class="keyword">new</span> <a class="code" href="classHamiltonian.html">Hamiltonian</a>(grid, NULL, particle_mass);</div>
<div class="line">    <a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t);</div>
<div class="line"></div>
<div class="line">    solver-&gt;<a class="code" href="classSolver.html#afef4d30f0fafcdd30e4bbd68ab4b8d18">evolve</a>(iterations, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(grid-&gt;<a class="code" href="classLattice.html#a38f04d58222c67992677fbb9c76ff023">mpi_rank</a> == 0){</div>
<div class="line">        state-&gt;<a class="code" href="classState.html#a30ef4054140d4add7904c2e75b879b2d">write_to_file</a>(<span class="stringliteral">&quot;evolved_state&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Squared norm: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#ac19c0fcf546647fd08c264010b02ee7b">get_squared_norm</a>();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Kinetic energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#a9ab0c2e624be8dc9e15cd6ebf4c83566">get_kinetic_energy</a>();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Total energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#aeb5ea40d4c6cba2312f05e839fb1cf8e">get_total_energy</a>() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span> solver;</div>
<div class="line">    <span class="keyword">delete</span> hamiltonian;</div>
<div class="line">    <span class="keyword">delete</span> state;</div>
<div class="line">    <span class="keyword">delete</span> grid;</div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="preprocessor"></span>    MPI_Finalize();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compile it with</p>
<div class="fragment"><div class="line">mpic++ -I/PATH/TO/TROTTERSUZUKI/HEADER -L/PATH/TO/TROTTERSUZUKI/LIBRARY simple_example_mpi.cpp -o simple_example_mpi -ltrottersuzuki</div>
</div><!-- fragment --><p>Keep in mind that the library itself has to be compiled with MPI to make it work.</p>
<p>The same caveats apply for execution as for the command-line interface. The MPI compilation disables OpenMP multicore execution in the CPU kernel, therefore you must launch a process for each CPU core you want use. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
