<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Massively Parallel Trotter-Suzuki Solver: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="vortex.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Massively Parallel Trotter-Suzuki Solver
   &#160;<span id="projectnumber">1.6.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="md_download.html"><span>Download&#160;and&#160;Installation</span></a></li>
      <li><a href="md_tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="md_examples.html"><span>Examples</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial is about using the C++ API. If you are interested in the Python version, refer to <a href="https://trotter-suzuki-mpi.readthedocs.io/">Read the Docs</a>.</p>
<p><b>Multicore computations</b></p>
<p>This example uses all cores on a single computer to calculate the total energy after evolving a sinusoid initial state. First we set the physical and simulation parameters of the model. We set the mass equal to one, we discretize the space in 500 lattice points in either direction, and we set the physical length to the same value. We would like to have a hundred iterations with 0.01 second between each:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> particle_mass = 1.;</div><div class="line"><span class="keywordtype">int</span> dimension = 500.;</div><div class="line"><span class="keywordtype">double</span> length = double(dimension);</div><div class="line"><span class="keywordtype">double</span> delta_t = 0.01;</div><div class="line"><span class="keywordtype">int</span> iterations  = 100;</div></div><!-- fragment --><p>The next step is the define the lattice, the state, and the <a class="el" href="classHamiltonian.html" title="This class defines the Hamiltonian of a single component system. ">Hamiltonian</a>:</p>
<div class="fragment"><div class="line">Lattice *grid = <span class="keyword">new</span> <a class="code" href="classLattice2D.html">Lattice2D</a>(dimension, length);</div><div class="line"><a class="code" href="classState.html">State</a> *state = <span class="keyword">new</span> <a class="code" href="classSinusoidState.html">SinusoidState</a>(grid, 1, 1);</div><div class="line"><a class="code" href="classHamiltonian.html">Hamiltonian</a> *hamiltonian = <span class="keyword">new</span> <a class="code" href="classHamiltonian.html">Hamiltonian</a>(grid, NULL, particle_mass);</div></div><!-- fragment --><p>Note that the state is centered around the origin and scaled according to the grid. The centering and scaling function is exposed to the user via the function <code>center_coordinates</code>.</p>
<p>With these objects representing the physics of the problem, we can initialize the solver:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t);</div></div><!-- fragment --><p>Then we can evolve the state for the hundred iterations:</p>
<div class="fragment"><div class="line">solver-&gt;<a class="code" href="classSolver.html#afef4d30f0fafcdd30e4bbd68ab4b8d18">evolve</a>(iterations);</div></div><!-- fragment --><p>If we would like to have imaginary time evolution to approximate the ground state of the system, a second boolean parameter can be passed to the <code>evolve</code> method. Flipping it to true will yield imaginary time evolution.</p>
<p>We can write the evolved state to a file:</p>
<div class="fragment"><div class="line">state-&gt;<a class="code" href="classState.html#a30ef4054140d4add7904c2e75b879b2d">write_to_file</a>(<span class="stringliteral">&quot;evolved_state&quot;</span>);</div></div><!-- fragment --><p>If we need a series of snapshots of the evolution, say, every hundred iterations, we can loop these two steps, adjusting the prefix of the file to be written to reflect the number of evolution steps.</p>
<p>Finally, we can calculate the expectation value of the energies:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Squared norm: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#ac19c0fcf546647fd08c264010b02ee7b">get_squared_norm</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; Kinetic energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#a9ab0c2e624be8dc9e15cd6ebf4c83566">get_kinetic_energy</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; Total energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#aeb5ea40d4c6cba2312f05e839fb1cf8e">get_total_energy</a>() &lt;&lt; std::endl;</div></div><!-- fragment --><p>The following file, <code>simple_example.cpp</code>, summarizes the above:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;trottersuzuki.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    <span class="keywordtype">double</span> particle_mass = 1.;</div><div class="line">    <span class="keywordtype">int</span> dimension = 500.;</div><div class="line">    <span class="keywordtype">double</span> length = double(dimension);</div><div class="line">    <span class="keywordtype">double</span> delta_t = 0.01;</div><div class="line">    <span class="keywordtype">int</span> iterations  = 100;</div><div class="line"></div><div class="line">    Lattice *grid = <span class="keyword">new</span> <a class="code" href="classLattice2D.html">Lattice2D</a>(dimension, length);</div><div class="line">    <a class="code" href="classState.html">State</a> *state = <span class="keyword">new</span> <a class="code" href="classSinusoidState.html">SinusoidState</a>(grid, 1, 1);</div><div class="line">    <a class="code" href="classHamiltonian.html">Hamiltonian</a> *hamiltonian = <span class="keyword">new</span> <a class="code" href="classHamiltonian.html">Hamiltonian</a>(grid, NULL, particle_mass);</div><div class="line">    <a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t);</div><div class="line"></div><div class="line">    solver-&gt;<a class="code" href="classSolver.html#afef4d30f0fafcdd30e4bbd68ab4b8d18">evolve</a>(iterations);</div><div class="line">    state-&gt;<a class="code" href="classState.html#a30ef4054140d4add7904c2e75b879b2d">write_to_file</a>(<span class="stringliteral">&quot;evolved_state&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Squared norm: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#ac19c0fcf546647fd08c264010b02ee7b">get_squared_norm</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Kinetic energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#a9ab0c2e624be8dc9e15cd6ebf4c83566">get_kinetic_energy</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Total energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#aeb5ea40d4c6cba2312f05e839fb1cf8e">get_total_energy</a>() &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">delete</span> solver;</div><div class="line">    <span class="keyword">delete</span> hamiltonian;</div><div class="line">    <span class="keyword">delete</span> state;</div><div class="line">    <span class="keyword">delete</span> grid;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Compile it with</p>
<div class="fragment"><div class="line">g++ -I/PATH/TO/TROTTERSUZUKI/HEADER -L/PATH/TO/TROTTERSUZUKI/LIBRARY simple_example.cpp -o simple_example -ltrottersuzuki</div></div><!-- fragment --><p><b>GPU version</b></p>
<p>If the library was compiled with CUDA support, it is enough to change a single line of code, requesting the GPU kernel when instantiating the solver class:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t, <span class="stringliteral">&quot;gpu&quot;</span>);</div></div><!-- fragment --><p>The compilation is the same as above. For using multiple GPUs, compile the code with MPI and launch one process for each GPU.</p>
<p><b>Distributed version</b></p>
<p>There is very little modification required in the code to make it work with MPI. It is sufficient to initialize MPI and finalize it before returning from <code>main</code>. It is worth noting that the <code>Lattice</code> class keeps track of the MPI-related topology, and it also knows the MPI rank of the current process. The code for <code>simple_example_mpi.cpp</code> is as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;trottersuzuki.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    <span class="keywordtype">double</span> particle_mass = 1.;</div><div class="line">    <span class="keywordtype">int</span> dimension = 500.;</div><div class="line">    <span class="keywordtype">double</span> length = double(dimension);</div><div class="line">    <span class="keywordtype">double</span> delta_t = 0.01;</div><div class="line">    <span class="keywordtype">int</span> iterations  = 100;</div><div class="line"></div><div class="line">    Lattice *grid = <span class="keyword">new</span> <a class="code" href="classLattice2D.html">Lattice2D</a>(dimension, length);</div><div class="line">    <a class="code" href="classState.html">State</a> *state = <span class="keyword">new</span> <a class="code" href="classSinusoidState.html">SinusoidState</a>(grid, 1, 1);</div><div class="line">    <a class="code" href="classHamiltonian.html">Hamiltonian</a> *hamiltonian = <span class="keyword">new</span> <a class="code" href="classHamiltonian.html">Hamiltonian</a>(grid, NULL, particle_mass);</div><div class="line">    <a class="code" href="classSolver.html">Solver</a> *solver = <span class="keyword">new</span> <a class="code" href="classSolver.html">Solver</a>(grid, state, hamiltonian, delta_t);</div><div class="line"></div><div class="line">    solver-&gt;<a class="code" href="classSolver.html#afef4d30f0fafcdd30e4bbd68ab4b8d18">evolve</a>(iterations, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(grid-&gt;mpi_rank == 0){</div><div class="line">        state-&gt;<a class="code" href="classState.html#a30ef4054140d4add7904c2e75b879b2d">write_to_file</a>(<span class="stringliteral">&quot;evolved_state&quot;</span>);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Squared norm: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#ac19c0fcf546647fd08c264010b02ee7b">get_squared_norm</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Kinetic energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#a9ab0c2e624be8dc9e15cd6ebf4c83566">get_kinetic_energy</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Total energy: &quot;</span> &lt;&lt; solver-&gt;<a class="code" href="classSolver.html#aeb5ea40d4c6cba2312f05e839fb1cf8e">get_total_energy</a>() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keyword">delete</span> solver;</div><div class="line">    <span class="keyword">delete</span> hamiltonian;</div><div class="line">    <span class="keyword">delete</span> state;</div><div class="line">    <span class="keyword">delete</span> grid;</div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Compile it with</p>
<div class="fragment"><div class="line">mpic++ -I/PATH/TO/TROTTERSUZUKI/HEADER -L/PATH/TO/TROTTERSUZUKI/LIBRARY simple_example_mpi.cpp -o simple_example_mpi -ltrottersuzuki</div></div><!-- fragment --><p>Keep in mind that the library itself has to be compiled with MPI to make it work.</p>
<p>The MPI compilation disables OpenMP multicore execution in the CPU kernel, therefore you must launch a process for each CPU core you want use. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
