<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Massively Parallel Trotter-Suzuki Solver: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Massively Parallel Trotter-Suzuki Solver
   &#160;<span id="projectnumber">1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Massively Parallel Trotter-Suzuki Solver Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Trotter-Suzuki approximation leads to an efficient algorithm for solving the time-dependent Sch√∂dinger equation. This library provides a scalable, high-precision implementation that uses parallel and distributed computational resources. The implementation built on <a href="https://bitbucket.org/zzzoom/trottersuzuki">single-node parallel kernels</a> [1], extending them to use distributed resources [2], and generalizing the kernels to be able to tackle a wider range of problems in quantum physics [3].</p>
<p>Key features:</p>
<ul>
<li>Arbitrary single-body initial state with closed and periodic boundary conditions.</li>
<li>Many-body simulations with non-interacting particles.</li>
<li><a href="https://github.com/Lucacalderaro/Master-Thesis/blob/master/Soliton%20generation%20on%20Bose-Einstein%20Condensate.ipynb">Gross-Pitaevskii equation</a>.</li>
<li>Imaginary time evolution to calculate the ground state.</li>
<li>Stationary external potential.</li>
<li>Command-line interface (CLI) and application programming interface (API) for flexible use.</li>
<li><a href="https://pypi.python.org/pypi/trottersuzuki">Python</a> and <a href="https://www.mathworks.com/matlabcentral/fileexchange/51975-mextrotter">MATLAB</a> wrappers are provided.</li>
<li>Cache optimized multi-core, SSE, GPU, and hybrid kernels.</li>
<li>Near-linear scaling across multiple nodes with computations overlapping communication.</li>
</ul>
<p>Download the latest stable release <a href="https://github.com/trotter_suzuki-mpi/trotter-suzuki-mpi/releases/latest">here</a>. The development version is <a href="https://github.com/trotter_suzuki-mpi/trotter-suzuki-mpi">available on GitHub</a>.</p>
<h2>Usage </h2>
<p><b>Command-line Interface</b></p>
<p>Usage: <code>trotter [OPTIONS] -n filename</code></p>
<p>The file specified contains the complex matrix describing the initial state in the position picture.</p>
<p>Arguments: </p><pre class="fragment">-m NUMBER     Particle mass
-c NUMBER     Coupling constant of the self-interacting term (default: 0)
-d NUMBER     Matrix dimension (default: 640)
-l NUMBER     Physical dimension of the square lattice's edge (default: 640)
-t NUMBER     Single time step (default: 0.01)
-i NUMBER     Number of iterations (default: 1000)
-g            Imaginary time evolution to evolve towards the ground state
-k NUMBER     Kernel type (default: 0): 
                0: CPU, cache-optimized
                1: CPU, SSE and cache-optimized
                2: GPU
                3: Hybrid CPU-GPU (experimental)                    
-s NUMBER     Snapshots are taken at every NUMBER of iterations.
                Zero means no snapshots. Default: 0.
-n FILENAME   The initial state.
-p FILENAME   Name of file that stores the potential operator 
              (in coordinate representation)
</pre><p>Examples:</p>
<p>For a single-threaded run for a hundred iterations with a GPU, starting on some initial state of size 640x640 in psi0.dat and taking snapshots at every ten iterations, enter: </p><pre class="fragment">trotter -k 2 -i 100 -d 640 -s 10 -n psi0.dat
</pre><p>For using eight cores with the CPU kernel, type: </p><pre class="fragment">mpirun -np 4 trotter -i 100 -d 640 -s 10 -n psi0.dat
</pre><p>Naturally, if the system is distributed, MPI must be told of a host file.</p>
<p>In case of the SSE kernel, the chunk of the matrix assigned to a node, that is, a tile, must have a width that is divisible by two. This puts a constraint on the possible matrix sizes. For instance, running twelve MPI threads in a 4x3 configuration, the dimensions must be divisible by six and eight.</p>
<p>The hybrid kernel is experimental. It splits the work between the GPU and the CPU. It uses one MPI thread per GPU, and uses OpenMP to use parallelism on the CPU. It can be faster than the GPU kernel alone, especially if the GPU is consumer-grade. The kernel is especially efficient if the matrix does not fit the GPU memory. For instance, given twelve physical cores in a single node with two Tesla C2050 GPUs, a 14,000x14,000 would not fit the GPU memory. The following command would calculate the part that does not fit the device memory on the CPU: </p><pre class="fragment">OMP_NUM_THREADS=6 mpirun -np 2 build/trotter -k 3 -i 100 -d 14000 -n psi0.dat
</pre><p><b>Application Programming Interface</b></p>
<p>If the command-line interface is not flexible enough, the function that performs the evolution is exposed as an API: </p><pre class="fragment">void trotter(double h_a, double h_b, double coupling_const,
             double * external_pot_real, double * external_pot_imag,
             double * p_real, double * p_imag, double delta_x, double delta_y,
             const int matrix_width, const int matrix_height,
             const int iterations, const int kernel_type,
             int *periods, double norm, bool imag_time);
</pre><p>where the parameters are as follows: </p><pre class="fragment">h_a               Kinetic term of the Hamiltonian (cosine part)
h_b               Kinetic term of the Hamiltonian (sine part)
coupling_const    Coupling constant of the self-interacting term
external_pot_real External potential, real part
external_pot_imag External potential, imaginary part
p_real            Initial state, real part
p_imag            Initial state, imaginary part
delta_x           Physical distance between two neighbour points of the lattice along the x axis
delta_y           Physical distance between two neighbour points of the lattice along the y axis
matrix_width      The width of the initial state
matrix_height     The height of the initial state
iterations        Number of iterations to be calculated
kernel_type       The kernel type:
                          0: CPU block kernel
                          1: CPU SSE block kernel
                          2: GPU kernel
                          3: Hybrid kernel
periods           Whether the grid is periodic in any of the directions
norm              Norm of the final state (only for imaginary time evolution)
imag_time         Optional parameter to calculate imaginary time evolution
</pre><p>MPI must be initialized before the function is called. Examples of using the API are included in the source tree. The respective files are in the examples folder:</p>
<ul>
<li><code>exponential_initial_state.cpp</code>: Time evolution of a particle in a box with an exponential initial state with periodic boundary conditions.</li>
<li><code>gaussian-like_initial_state.cpp</code>: Time evolution of a particle in a box with a Gaussian-like initial state with closed boundary conditions.</li>
<li><code>imag_evolution.cpp</code>: Imaginary time evolution of an exponential initial state with periodic boundary conditions.</li>
<li><code>sinusoid_initial_state.cpp</code>: Time evolution of a particle in a box with a sinusoid initial state with periodic boundary conditions.</li>
<li><code>groundstate_of_BEC_in_harmonic_pot.cpp</code>: Imaginary time evolution of a Bose-Einstein Condensate trapped in a harmonic potential.</li>
</ul>
<p><b>Python and MATLAB Interfaces</b></p>
<p>The CPU and SSE kernels are accessible from Python and MATLAB. The Python version is available on the <a href="https://pypi.python.org/pypi/trottersuzuki">Python Package Index</a>, whereas the MATLAB version is available on the <a href="http://www.mathworks.com/matlabcentral/fileexchange/51975-mextrotter">MATLAB File Exchange</a>. Please refer to the documentation of these packages for further information.</p>
<h2>Compilation &amp; Installation </h2>
<p>The code was tested with the GNU Compiler Chain (GCC), with Intel compilers, and with Visual Studio. The unit testing framework is separate and it requires <a href="http://sourceforge.net/projects/cppunit/">CppUnit</a> to compile. To use the GPU-accelerated version, CUDA and a GPU with at least Compute Cabapility 2.0 are necessary.</p>
<p><b>Building on Linux</b></p>
<p>If you clone the git repository, first run </p><pre class="fragment">$ ./autogen.sh
</pre><p>Then follow the standard POSIX procedure: </p><pre class="fragment">$ ./configure [options]
$ make
$ make install
</pre><p>To compile and run the unit tests, enter </p><pre class="fragment">$ make test
$ test/unittest
</pre><p>If you prefer the Intel compilers you have to set the following variables, so mpic++ will invoke icpc instead of the default compiler: </p><pre class="fragment">$ export CC=/path/of/intel/compiler/icc
$ export CXX=/path/of/intel/compiler/icpc
$ export OMPI_CC=/path/of/intel/compiler/icc
$ export OMPI_CXX=/path/of/intel/compiler/icpc
</pre><p>Options for configure </p><pre class="fragment">--prefix=PATH           Set directory prefix for installation
</pre><p>By default, the executable is installed into /usr/local. If you prefer a different location, use this option to select an installation directory. </p><pre class="fragment">--with-mpi=MPIROOT      Use MPI root directory.
--with-mpi-compilers=DIR or --with-mpi-compilers=yes
                          use MPI compiler (mpicxx) found in directory DIR, or
                          in your PATH if =yes
--with-mpi-libs=LIBS  MPI libraries [default "-lmpi"]
--with-mpi-incdir=DIR   MPI include directory [default MPIROOT/include]
--with-mpi-libdir=DIR   MPI library directory [default MPIROOT/lib]
</pre><p>The above flags allow the identification of the correct MPI library the user wishes to use. The flags are especially useful if MPI is installed in a non-standard location, or when multiple MPI libraries are available. </p><pre class="fragment">--with-cuda=/path/to/cuda           Set path for CUDA
</pre><p>The configure script looks for CUDA in /usr/local/cuda. If your installation is elsewhere, then specify the path with this parameter. If you do not want CUDA enabled, set the parameter to <code>--without-cuda</code>.</p>
<h2>Acknowledgement </h2>
<p>The <a href="https://bitbucket.org/zzzoom/trottersuzuki">original high-performance kernels</a> were developed by Carlos Bederi√°n. The distributed extension was carried out while <a href="http://peterwittek.com/">Peter Wittek</a> was visiting the <a href="http://www.bsc.es/computer-applications">Department of Computer Applications in Science &amp; Engineering</a> at the <a href="http://www.bsc.es/">Barcelona Supercomputing Center</a>, funded by the "Access to BSC Facilities" project of the <a href="http://www.hpc-europa.org/">HPC-Europe2</a> programme (contract no. 228398). Generalizing the capabilities of kernels was carried out by Luca Calderaro while visiting the <a href="https://www.icfo.eu/research/group_details.php?id=19">Quantum Information Theory Group</a> at <a href="https://www.icfo.eu/">ICFO-The Institute of Photonic Sciences</a>, sponsored by the <a href="http://ec.europa.eu/programmes/erasmus-plus/index_en.htm">Erasmus+</a> programme.</p>
<h2>References </h2>
<ol type="1">
<li>Bederi√°n, C. &amp; Dente, A. Boosting quantum evolutions using Trotter-Suzuki algorithms on GPUs. <em>Proceedings of HPCLatAm-11, 4th High-Performance Computing Symposium</em>, 2011. <a href="http://www.famaf.unc.edu.ar/grupos/GPGPU/boosting_trotter-suzuki.pdf">PDF</a></li>
<li>Wittek, P. and Cucchietti, F.M. (2013). <a href="http://dx.doi.org/10.1016/j.cpc.2012.12.008">A Second-Order Distributed Trotter-Suzuki Solver with a Hybrid CPU-GPU Kernel</a>. <em>Computer Physics Communications</em>, 184, pp. 1165-1171. <a href="http://arxiv.org/pdf/1208.2407">PDF</a></li>
<li>Wittek, P. and Calderaro, L. (2015). <a href="http://dx.doi.org/10.1016/j.cpc.2015.07.017">Extended computational kernels in a massively parallel implementation of the Trotter-Suzuki approximation</a>. <em>Computer Physics Communications</em>. <a href="https://www.researchgate.net/profile/Peter_Wittek/publication/280962265_Extended_Computational_Kernels_in_a_Massively_Parallel_Implementation_of_the_TrotterSuzuki_Approximation/links/55cebd1f08aee19936fc5dcf.pdf">PDF</a> </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
